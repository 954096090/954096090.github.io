<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Silicon4的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Silicon4">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Silicon4">
<meta property="og:description" content="Silicon4的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Silicon4">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Silicon4</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silicon4</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">科学，就是“偶尔能解答，常常在疑惑，总是在探寻”</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/EXTI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/EXTI/" itemprop="url">EXTI外部中断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T17:56:55+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="STM32的外部中断结构"><a href="#STM32的外部中断结构" class="headerlink" title="STM32的外部中断结构"></a>STM32的外部中断结构</h2><p>STM32所有的IO口都支持外部中断，大致的结构呢，我画一个图：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200507180035564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="EXTI"></p>
<p>就是每组的IO口的所有引脚都可以对应有一个中断线，但是每个中断线只能在一组引脚生效，在图像上的意思就是，每一行可以有多个交点可以设置中断，但每一列只能有一个交点可以设置中断。</p>
<p>这是F103所有的中断线：</p>
<p>EXTI 线 0~15：对应外部 IO 口的输入中断。</p>
<p> EXTI 线 16：连接到 PVD 输出。</p>
<p> EXTI 线 17：连接到 RTC 闹钟事件。</p>
<p>EXTI 线 18：连接到 USB 唤醒事件。 </p>
<p>EXTI 线 19：连接到以太网唤醒事件。</p>
<h2 id="外部中断控制LED例程"><a href="#外部中断控制LED例程" class="headerlink" title="外部中断控制LED例程"></a>外部中断控制LED例程</h2><p>和GPIO，USART，KEY，这些一样，我也单独写一个外部中断的inc和src文件，方便以后拓展。</p>
<p>先来了解一下基于HAL库的大致操作步骤：</p>
<ol>
<li>使能 <strong>IO 口时钟</strong>，初始化 IO 口为输入</li>
<li>设置 <strong>IO 口模式</strong>，触发条件，开启 SYSCFG 时钟，设置 IO 口与中断线的映射关系</li>
<li>配置<strong>中断优先级</strong>（NVIC），并<strong>使能中断</strong></li>
<li>编写<strong>中断服务函数</strong>。</li>
<li>编写中断处理<strong>回调函数</strong> HAL_GPIO_EXTI_Callback</li>
</ol>
<h4 id="EXTI-h"><a href="#EXTI-h" class="headerlink" title="EXTI.h"></a>EXTI.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __EXTI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__EXTI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx_hal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="EXTI-c"><a href="#EXTI-c" class="headerlink" title="EXTI.c"></a>EXTI.c</h4><p>这里包含3个部分：</p>
<p><strong>1、初始化函数</strong>：我的开发板有两个按键，分别在PE3，PE4两个口，另一端接GND，也就是说按下就是使IO口接地，因此，先<strong>使能IO口时钟</strong>，同时设置PIN_3和PIN_4为<strong>上拉输入</strong>，<strong>下降沿触发</strong>。由于是手按的按键，速度<strong>默认低速</strong>就很合适。这里相比固件库，HAL库直接就配置成了外部中断模式，很是方便，下面只要设置<strong>中断优先级</strong>，并且<strong>使能外部中断</strong>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"EXTI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KEY.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DELAY.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_RCC_GPIOE_CLK_ENABLE();               <span class="comment">//开启GPIOE时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_4;</span><br><span class="line">	GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;			<span class="comment">//外部中断下降沿触发</span></span><br><span class="line">	GPIO_InitStructure.Pull = GPIO_PULLUP;				<span class="comment">//上拉拉输入</span></span><br><span class="line">	</span><br><span class="line">	HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//中断线3-PE3</span></span><br><span class="line">    HAL_NVIC_SetPriority(EXTI3_IRQn,<span class="number">2</span>,<span class="number">2</span>);       <span class="comment">//抢占优先级为2，子优先级为2</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(EXTI3_IRQn);             <span class="comment">//使能中断线2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中断线4-PE4</span></span><br><span class="line">    HAL_NVIC_SetPriority(EXTI4_IRQn,<span class="number">2</span>,<span class="number">3</span>);   	<span class="comment">//抢占优先级为2，子优先级为3</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(EXTI4_IRQn);         	<span class="comment">//使能中断线4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、外部中断服务函数：</strong>这里也很简单，因为ST帮我们设置好了处理函数，和USART一样，在HAL库的处理函数中，先失能中断，防止再次进入中断，再判断具体是哪个中断线发生了中断，然后在处理函数中调用CallBack回调函数，而回调函数才是真正的用户函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);		<span class="comment">//调用中断处理公用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);		<span class="comment">//调用中断处理公用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳转进这个神奇的函数，可以看到其实还是很简单的，没有串口的HAL_USART_IRQHandler那么虐心：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是再次确认有外部中断发生，清除中断标志位，然后便进入回调函数：</p>
<p><strong>3、回调函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   HAL_Delay(<span class="number">100</span>);						<span class="comment">//延时消抖</span></span><br><span class="line">    <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_3:</span><br><span class="line">            <span class="keyword">if</span>(Read_KEY1==<span class="number">0</span>)  					<span class="comment">//控制LED1反转</span></span><br><span class="line">            &#123;</span><br><span class="line">				HAL_GPIO_TogglePin(LED0_GPIO, LED0_PIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_4:</span><br><span class="line">            <span class="keyword">if</span>(Read_KEY0==<span class="number">0</span>)  </span><br><span class="line">            &#123;</span><br><span class="line">				HAL_GPIO_TogglePin(LED1_GPIO, LED1_PIN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在这个文件里包含了LED.h和KEY.h所以直接使用相关的宏，完成<strong>按键的再检测</strong>，以及对LED的翻转操作，这里是一个按键操作一个LED灯。</p>
<h2 id="新的问题"><a href="#新的问题" class="headerlink" title="　新的问题"></a>　新的问题</h2><p>重点不在这里，这里有一个坑，就这么写的话，只要按一次按键，程序就会进入中断回调函数永远也出不来，调试了半天，发现程序最后进入HAL_Delay里面，在里面死循环。┗|｀O′|┛ 嗷~~原来是HAL_Delay搞的鬼。</p>
<p>以前从没有在中断里写HAL_Delay，这次心里觉得，既然是官方给的延时函数，应该精确又好用嘛，但是查了Bing，深究了这个延时函数的原理才发现问题的根本，该函数只有一个32位的参数，这个形参指定了延时的时间，它的单位是毫秒(<strong>ms</strong>)。</p>
<p>系统的滴答时钟，Systick定时器每<strong>中断</strong>一次，就调用一次HAL_incTick()函数，来对变量<strong>uwTick累加</strong>。当程序进入延时函数时，就调用HAL_GetTick()获取当前uwTick的值。接着<strong>判断wait的值</strong>，若不大于可以延时的最大值，则wait自加1，最后不断的获取HAl_GetTick的值，直到这个值和初始值的差不小于等待的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_Delay</span><span class="params">(<span class="keyword">uint32_t</span> Delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tickstart = HAL_GetTick();</span><br><span class="line">  <span class="keyword">uint32_t</span> wait = Delay;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add a freq to guarantee minimum wait */</span></span><br><span class="line">  <span class="keyword">if</span> (wait &lt; HAL_MAX_DELAY)</span><br><span class="line">  &#123;</span><br><span class="line">    wait += (<span class="keyword">uint32_t</span>)(uwTickFreq);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((HAL_GetTick() - tickstart) &lt; wait)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，HAL_Delay的工作是<strong>需要中断</strong>的，既然涉及到中断，就有<strong>优先级</strong>，这个SystemTick的抢占优先级默认低于所有的核外片内外设，也就是说，SystemTick<strong>定时器中断无法打断外部中断</strong>，注意<strong>此时程序运行到CallBack函数，这个函数仍然包含在中断服务函数中</strong>，因此程序虽然进入了HAL_Delay中，但是SystemTick永远无法运行，于是就卡在了HAL_Delay中。</p>
<p><strong>解决方法：</strong></p>
<p>利用轮回查询法，获取延时功能：</p>
<h4 id="DELAY-h"><a href="#DELAY-h" class="headerlink" title="DELAY.h"></a>DELAY.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx_hal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_Init</span><span class="params">(<span class="keyword">uint8_t</span> SYSCLK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">uint16_t</span> nms)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_us</span><span class="params">(<span class="keyword">uint32_t</span> nus)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="DELAY-c"><a href="#DELAY-c" class="headerlink" title="DELAY.c"></a>DELAY.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DELAY.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> fac_us=<span class="number">0</span>;							<span class="comment">//us延时倍乘数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_Init</span><span class="params">(<span class="keyword">uint8_t</span> SYSCLK)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);<span class="comment">//SysTick频率为HCLK</span></span><br><span class="line">	fac_us=SYSCLK;						<span class="comment">//不论是否使用OS,fac_us都需要使用</span></span><br><span class="line"></span><br><span class="line">&#125;								    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_us</span><span class="params">(<span class="keyword">uint32_t</span> nus)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="keyword">uint32_t</span> ticks;</span><br><span class="line">	<span class="keyword">uint32_t</span> told,tnow,tcnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> reload=SysTick-&gt;LOAD;				<span class="comment">//LOAD的值	    	 </span></span><br><span class="line">	ticks=nus*fac_us; 							<span class="comment">//需要的节拍数 </span></span><br><span class="line">	told=SysTick-&gt;VAL;        					<span class="comment">//刚进入时的计数器值</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tnow=SysTick-&gt;VAL;	</span><br><span class="line">		<span class="keyword">if</span>(tnow!=told)</span><br><span class="line">		&#123;	    </span><br><span class="line">			<span class="keyword">if</span>(tnow&lt;told)tcnt+=told-tnow;	<span class="comment">//这里注意一下SYSTICK是一个递减的计数器就可以了.</span></span><br><span class="line">			<span class="keyword">else</span> tcnt+=reload-tnow+told;	    </span><br><span class="line">			told=tnow;</span><br><span class="line">			<span class="keyword">if</span>(tcnt&gt;=ticks)<span class="keyword">break</span>;			<span class="comment">//时间超过/等于要延迟的时间,则退出.</span></span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(<span class="keyword">uint16_t</span> nms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nms;i++) Delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面节选正点原子对时钟摘取法的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里我们利用的是时钟摘取法。以 delay_us 为例，比如</span></span><br><span class="line"><span class="comment">delay_us(50)，在刚进入 delay_us 的时候先计算好这段延时需要等待的 SysTick 计数次数，这里</span></span><br><span class="line"><span class="comment">为 50*9（假设系统时钟为 72Mhz，那么 SysTick 每增加 1，就是 1/72us），然后我们就一直统计</span></span><br><span class="line"><span class="comment">SysTick 的计数变化，直到这个值变化了 50*9，一旦检测到变化达到或者超过这个值，就说明</span></span><br><span class="line"><span class="comment">延时 50us 时间到了。这样，我们只是抓取 SysTick 计数器的变化，并不需要修改 SysTick 的任</span></span><br><span class="line"><span class="comment">何状态，完全不影响 SysTick 作为 UCOS 时钟节拍的功能，这就是实现 delay 和操作系统共用</span></span><br><span class="line"><span class="comment">SysTick 定时器的原理。*/</span></span><br></pre></td></tr></table></figure>
<p><strong>这样做和HAL_Delay的本质区别就是：</strong></p>
<p>SYSTick其实一直在跑，但是HAL_Delay的函数HAL_GetTick()需要进入中断来读取它的值，但是程序进入其他的外设中断，就永远读不到这个值了。</p>
<p>而时钟摘取法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnow=SysTick-&gt;VAL;</span><br></pre></td></tr></table></figure>
<p>而SysTick使系统的宏定义，在core_cm3.h的内核头文件中，core_cm3.h包含于stm32f103xe.h这个ST公司的HAL库头文件中，stm32f103xe.h又包含于stm32f1xx.h这个选型头文件中，而我的每个外设文件都要包含stm32f1xx.h这个选型文件和stm32f10x_hal.h。</p>
<p>扯远了，这里就通过直接读取寄存器的方法，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SysTick             ((SysTick_Type   *)     SysTick_BASE  )   <span class="comment">/*!&lt; SysTick configuration struct */</span></span></span><br></pre></td></tr></table></figure>
<p>只要计数开始，就一直在摘取SysTick的值，并与进入延时时取到的值作比较，读到需要结束的数值，就延时完毕，结束延时函数。</p>
<p>在主函数开始进行初始化，然后就可以使用这个新的延时函数在中断中进行延时了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/" itemprop="url">USART模块(串口通信)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-05T21:46:12+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="STM32的串口模块总体理解"><a href="#STM32的串口模块总体理解" class="headerlink" title="STM32的串口模块总体理解"></a>STM32的串口模块总体理解</h2><p>这个应该是第一次接触各种MCU串口的第一个尝试吧，我也是从这里开始的。</p>
<p>串口我们都不陌生，一般现在都用的TTL电平，再通过TTL转串口或者TTL转232与电脑主机进行通信，便于调试MCU程序，或者直接与其他MCU或者从设备进行通信，最少只需要3根线：RX，TX，GND(需要共地嘛)。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200505223115328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="USART框架结构"></p>
<p>TX：发送数据输出引脚</p>
<p>RX：接收数据输入引脚</p>
<p>SW_RX：数据接收引脚，仅用于单线和智能卡模式，属于内部引脚</p>
<p>nRTS：Request To Send 请求发送，n表示低电平有效，仅用于硬件流控制。如果使能RTS硬件流控制，当USART接收器准备好接收新数据时就会将nRST硬件复位0；当接收寄存器已满时，nRTS将被硬件置位1。</p>
<p>nCTS：Clear To Send 清除以发送，同样n表示低电平有效，仅用于硬件流控制。如果使能CTS硬件流控制，发送器在发送下一帧之前会检测nCTS引脚，如果为低电平，则表示可以发送数据，如果是高电平则在发送完当前数据帧之后就停止发送。</p>
<p>IRDA_OUT/IRDA_IN：用于红外传输数据。</p>
<p>SCLK：发送器时钟输出引脚，仅用于用于串口的同步模式。</p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200505220545830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="USART_DR"></p>
<p>USART_DR(数据寄存器)只有低9位有效，第9位数据是否有效取决于USART_CR1(控制寄存器1)的M位设置，当M位为0时表示8位数据字长，当M位为1表示9位数据字长，通常使用8位数据字长。USART_DR包含了已发送的数据或者接收到的数据，实际上包含了两个寄存器，一个专门用于发送的可写TDR，另一个专门用于接收的刻度RDR。当需要发送数据，内核或者DMA外设会嘛数据从内存写入到发送数据TDR。而TDR和RDR都是处于系统总线和移位寄存器之间，发送时，TDR的数据转移到发送移位寄存器，然后从移位寄存器一位一位发送出去。接收数据就是一个逆向个过程，数据一位一位输入接收移位寄存器，然后转移到RDR，最后由内核或者DMA读取到内存中。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>USART有专门的控制发送的发送器，控制接收的接收器，还有唤醒单元，中断控制等等，使用USART_CR1寄存器中的UE位置位，使能USART。</p>
<p><strong>发送器</strong>：当TE(发送使能位)置1时，发送移位寄存器中的数据在TX引脚上输出，如果时同步模式，在SCLK引脚输出时钟脉冲。每个字符前都有一个低电平的起始，之后跟着停止位，默认有1个停止位，可以更改为0.5/1/1.5/2个停止位，默认使用1个停止位。也可以通过USART_CR2的STOP位控制停止位数，以应用智能卡，调制解调器模式等应用需求。在发送数据时，发送器对TE位置1，发送一个空闲帧作为第一次数据发送，把发送的数据写入USART_DR寄存器，写入最后一个字节后，等待TC=1，表示最后一个数据帧传输结束。如果USART_CR1寄存器的TCIE被置位，就会产生中断。</p>
<p><strong>接收器</strong>：设置USART_CR1的RE位。激活接收器，使它开始寻找起始位。在确定到起始位后就会根据RX的电平状态把数据放在接收移位寄存器中。接收完成后将移位寄存器数据转移到RDR中，并把USART_SR寄存器中的RXNR位置1，，标明数据已经被接收并且可以被读出。如果USART_SR中的RXNEIE位被置1，表示产生中断。</p>
<h3 id="波特率设置"><a href="#波特率设置" class="headerlink" title="波特率设置"></a>波特率设置</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200505220550795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="USART_BRR"></p>
<p>波特率，每秒传输的位数，b/s(bit per second)，通过对时钟的控制可以改变波特率。配置波特率主要使用USART_BRR寄存器，修改串口时钟的分频USART_DIV。USART_BRR寄存器分为两部分，一个是DIV_Mantissa(整数部分)和DIV_Fraction(小数部分)，最终的串口波特率计算公式为，USART_DIV=DIC_Mantissa+(DIVFraction/16)</p>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><p>USART_SR，顾名思义，主要是根据串口的运行状态，由硬件将相应的位置位，有些位通过写0复位，有些则需要一些其他的用户操作来置位，由程序去读这个寄存器，便可以获知状态。</p>
<h2 id="基于HAL库的入门应用"><a href="#基于HAL库的入门应用" class="headerlink" title="基于HAL库的入门应用"></a>基于HAL库的入门应用</h2><p>一个外设，虽然是片上外设，但是我们也给它单独封装一下，方便以后白嫖自己的代码。</p>
<h3 id="USART-h"><a href="#USART-h" class="headerlink" title="USART.h"></a>USART.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口波特率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BOUND				115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引脚定义</span></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_RX_GPIO_PORT			GPIOA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_RX_GPIO_CLK_ENABLE()	__HAL_RCC_GPIOA_CLK_ENABLE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_RX_PIN					GPIO_PIN_10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_TX_GPIO_PORT			GPIOA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_TX_GPIO_CLK_ENABLE()	__HAL_RCC_GPIOA_CLK_ENABLE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_TX_PIN					GPIO_PIN_9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_IRQHandler				USART1_IRQHandler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		USART_IRQ						USART1_IRQn</span></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart_SendString</span><span class="params">(<span class="keyword">uint8_t</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *f)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef UART1_HandleStructure;</span><br><span class="line"><span class="comment">/*这一个异常重要啊，extern关键词很多人不会用，我在这之前也没用过，</span></span><br><span class="line"><span class="comment">但是这里必须保证这个变量在当前的头文件被stm32f1xx_it.c引用时，</span></span><br><span class="line"><span class="comment">里面的中断服务函数判断中断时要用到的，要保证能识别这个*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __USART1_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="USART-c"><a href="#USART-c" class="headerlink" title="USART.c"></a>USART.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"USART.h"</span></span></span><br><span class="line"></span><br><span class="line">UART_HandleTypeDef UART1_HandleStructure;</span><br><span class="line"><span class="comment">//extern uint8_t ucTemp;  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  UART1_HandleStructure.Instance          = USART1;</span><br><span class="line">  </span><br><span class="line">  UART1_HandleStructure.Init.BaudRate     = BOUND;					<span class="comment">//设置波特率</span></span><br><span class="line">  UART1_HandleStructure.Init.WordLength   = UART_WORDLENGTH_8B;		<span class="comment">//8位数据输出格式</span></span><br><span class="line">  UART1_HandleStructure.Init.StopBits     = UART_STOPBITS_1;		<span class="comment">//1个停止位</span></span><br><span class="line">  UART1_HandleStructure.Init.Parity       = UART_PARITY_NONE;		<span class="comment">//无奇偶校验位</span></span><br><span class="line">  UART1_HandleStructure.Init.HwFlowCtl    = UART_HWCONTROL_NONE;	<span class="comment">//无硬件流控</span></span><br><span class="line">  UART1_HandleStructure.Init.Mode         = UART_MODE_TX_RX;		<span class="comment">//双工收发模式</span></span><br><span class="line">  </span><br><span class="line">  HAL_UART_Init(&amp;UART1_HandleStructure);							<span class="comment">//利用初始化结构体使能UART1</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/*使能串口接收断 */</span></span><br><span class="line">  __HAL_UART_ENABLE_IT(&amp;UART1_HandleStructure,UART_IT_RXNE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，最重要的就是<strong>串口初始化函数</strong>，可以看到和GPIO一样，使用一个初始化结构体，利用官方定义好的宏，为对应的成员写上参数，然后用HAL库的初始化函数，进行一次性的初始化。当然，这是不够初始化的，因为HAL_USART_Init函数的内部，还会跳转到另外一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//GPIO端口设置</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(huart-&gt;Instance==USART1)<span class="comment">//如果是串口1，进行串口1 MSP初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		__HAL_RCC_GPIOA_CLK_ENABLE();			<span class="comment">//使能GPIOA时钟</span></span><br><span class="line">		__HAL_RCC_USART1_CLK_ENABLE();			<span class="comment">//使能USART1时钟</span></span><br><span class="line">		__HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line">		<span class="comment">/**USART1 GPIO Configuration    </span></span><br><span class="line"><span class="comment">		PA9     ------&gt; USART1_TX</span></span><br><span class="line"><span class="comment">		PA10    ------&gt; USART1_RX </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">/* 配置Tx引脚为复用功能  */</span></span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_9;			<span class="comment">//PA9</span></span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_AF_PP;		<span class="comment">//复用推挽输出</span></span><br><span class="line">		GPIO_Initure.Pull=GPIO_PULLUP;			<span class="comment">//上拉</span></span><br><span class="line">		GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;<span class="comment">//高速</span></span><br><span class="line">		HAL_GPIO_Init(GPIOA,&amp;GPIO_Initure);	   	<span class="comment">//初始化PA9</span></span><br><span class="line">		<span class="comment">/* 配置Rx引脚为复用功能 */</span></span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_10;			<span class="comment">//PA10</span></span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_AF_INPUT;	<span class="comment">//模式要设置为复用输入模式！	</span></span><br><span class="line">		HAL_GPIO_Init(GPIOA,&amp;GPIO_Initure);	   	<span class="comment">//初始化PA10</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">		HAL_NVIC_EnableIRQ(USART1_IRQn);				<span class="comment">//使能USART1中断通道</span></span><br><span class="line">		HAL_NVIC_SetPriority(USART1_IRQn,<span class="number">3</span>,<span class="number">3</span>);			<span class="comment">//抢占优先级3，子优先级3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个HAL_USART_MspInit函数是系统弱定义函数，什么都不写，如果不强定义，填充内容的话，就会跳转并执行一个空函数，所以要在这里进行相关的端口复用设置。</p>
<ul>
<li>开启相应GPIO和USART1的<strong>时钟</strong></li>
<li>将RX接收引脚设置为<strong>复用输入</strong></li>
<li>将TX发送引脚设置为<strong>复用推挽输出</strong></li>
<li>在这里我打算在主程序放之前那个按键扫描程序，因此需要用到中断，<strong>使能中断，设优先级</strong>。</li>
</ul>
<p>另外，再定义一些发送接收函数(这一段是白嫖的，当然还是过了脑子)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************  发送字符串 **********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart_SendString</span><span class="params">(<span class="keyword">uint8_t</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">  &#123;</span><br><span class="line">      HAL_UART_Transmit(&amp;UART1_HandleStructure,(<span class="keyword">uint8_t</span> *)(str + k) ,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">      k++;</span><br><span class="line">  &#125; <span class="keyword">while</span>(*(str + k)!=<span class="string">'\0'</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重定向c库函数printf到串口DEBUG_USART，重定向后可使用printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 发送一个字节数据到串口DEBUG_USART */</span></span><br><span class="line">	HAL_UART_Transmit(&amp;UART1_HandleStructure, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">1000</span>);	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向c库函数scanf到串口DEBUG_USART，重写向后可使用scanf、getchar等函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	HAL_UART_Receive(&amp;UART1_HandleStructure, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">1000</span>);	</span><br><span class="line">	<span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么USART.c文件到这里就写完了，直接在函数里初始化就可以了吗？不不不</p>
<h3 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h3><p>都学过51吧，是不是到这里总觉得少了点什么，我一开始也纳闷，这白嫖来的发送函数怎么发不出去啊。好吧，仔细看还需要配置中断服务函数的。</p>
<p>打开<strong>stm32f1xx_it.c</strong>，在他的包含头文件下面写上自己的用到中断的外设头文件，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx_it.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"USART.h"</span>							<span class="comment">//这一条是新增加的</span></span></span><br></pre></td></tr></table></figure>
<p>……(中间省略一些原来的函数)在这个c文件的最末尾加上1个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> ch=<span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(__HAL_UART_GET_FLAG( &amp;UART1_HandleStructure, UART_FLAG_RXNE ) != RESET)</span><br><span class="line">	&#123;		</span><br><span class="line">    ch=( <span class="keyword">uint16_t</span>)READ_REG(UART1_HandleStructure.Instance-&gt;DR);</span><br><span class="line">    WRITE_REG(UART1_HandleStructure.Instance-&gt;DR,ch); </span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个呢，其实所有的中断服务函数，都在启动文件”startup_stm32f103xe.s”里面给我们定义好了，只不过还是个弱定义，是空的，我们在这里集中放上我们的中断服务函数，就可以在中断发生的时候顺利跳转到中断服务函数。</p>
<p>__HAL_UART_GET_FLAG是一个判断串口状态的函数，这里再来回顾一下理论：</p>
<ol>
<li><p>我之前在初始化函数中手动开启了接收中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使能串口接收断 */</span></span><br><span class="line">__HAL_UART_ENABLE_IT(&amp;UART1_HandleStructure,UART_IT_RXNE);</span><br></pre></td></tr></table></figure>
<p>根据数据手册，这里是操作了USART_CR1的RXNEIE，手册里翻译为<strong>接收缓冲区非空中断使能</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200506132856505.png" alt="RXNEIE"></p>
<p>原理呢，是通过开启后，判断状态寄存器的相应的接收状态位来判断中断。</p>
</li>
<li><p><strong>无论</strong>发生什么串口中断，程序会立即停止主函数的执行，跳转到启动文件中断向量表中的对应中断，在这里也就是<strong>USART1_IQRHandler</strong>。</p>
</li>
<li><p>在中断服务函数USART1_IQRHandler中，需要判断到底是何种中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(__HAL_UART_GET_FLAG( &amp;UART1_HandleStructure, UART_FLAG_RXNE ) != RESET)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这里判断的确发生了<strong>接收中断</strong>(全称叫<strong>接收缓冲区非空中断</strong>)，于是进行中断处理。</p>
</li>
</ol>
<h2 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h2><p>上面的一个历程，我们仅仅是设置的最最基础的功能，一旦接收到字符，就触发了中断，一次只能接收一个字符，就算发送一串字符给单片机，也是一个一个接收的，这跟51单片机没什么区别啊，反而配置倒麻烦了许多。</p>
<p>首先，HAL库是给我们提供了一个缓冲区的，先来看一下上面的入门应用中国涉及到的结构体吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">UART_HandleTypeDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  USART_TypeDef                 *Instance;</span><br><span class="line">  UART_InitTypeDef              Init;</span><br><span class="line">  <span class="keyword">uint8_t</span>                       *pTxBuffPtr;				<span class="comment">//1</span></span><br><span class="line">  <span class="keyword">uint16_t</span>                      TxXferSize;					<span class="comment">//2</span></span><br><span class="line">  __IO <span class="keyword">uint16_t</span>                 TxXferCount;				<span class="comment">//3</span></span><br><span class="line">  <span class="keyword">uint8_t</span>                       *pRxBuffPtr;				<span class="comment">//4</span></span><br><span class="line">  <span class="keyword">uint16_t</span>                      RxXferSize;					<span class="comment">//5</span></span><br><span class="line">  __IO <span class="keyword">uint16_t</span>                 RxXferCount;				<span class="comment">//6</span></span><br><span class="line">  DMA_HandleTypeDef             *hdmatx;</span><br><span class="line">  DMA_HandleTypeDef             *hdmarx;</span><br><span class="line">  HAL_LockTypeDef               Lock;</span><br><span class="line">  __IO HAL_UART_StateTypeDef    gState;</span><br><span class="line">  __IO HAL_UART_StateTypeDef    RxState;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span>                 ErrorCode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)</span></span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* USE_HAL_UART_REGISTER_CALLBACKS */</span></span></span><br><span class="line"></span><br><span class="line">&#125; UART_HandleTypeDef;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套的几个结构体"><a href="#嵌套的几个结构体" class="headerlink" title="嵌套的几个结构体"></a>嵌套的几个结构体</h3><ul>
<li>Instance 是 USART_TypeDef 结构体指针类型变量，它是执行寄存器基地址，实际上这个基地址HAL 库已经定义好了，如果是串口 1，这个成员取值为 USART1 即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> SR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> DR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> BRR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CR1;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CR2;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CR3;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> GTPR;</span><br><span class="line">&#125; USART_TypeDef;</span><br></pre></td></tr></table></figure>
<ul>
<li>Init 是 UART_InitTypeDef 结构体类型变量，它是用来设置串口的各个参数，包括波特率， 停止位等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> BaudRate;</span><br><span class="line">  <span class="keyword">uint32_t</span> WordLength;</span><br><span class="line">  <span class="keyword">uint32_t</span> StopBits;</span><br><span class="line">  <span class="keyword">uint32_t</span> Parity;</span><br><span class="line">  <span class="keyword">uint32_t</span> Mode;</span><br><span class="line">  <span class="keyword">uint32_t</span> HwFlowCtl;</span><br><span class="line">  <span class="keyword">uint32_t</span> OverSampling;</span><br><span class="line">&#125; UART_InitTypeDef;</span><br></pre></td></tr></table></figure>
<ul>
<li>hdmatx 和 hdmarx 是串口 DMA 相关的变量，这里没有使用DMA来处理，暂时不管。</li>
</ul>
<h3 id="6个中间变量"><a href="#6个中间变量" class="headerlink" title="6个中间变量"></a>6个中间变量</h3><ul>
<li>串口发送：pTxBuffPtr数据缓存指针，TxXferSize发送的数据量，TxXferCount剩余未发送的数据量</li>
<li>串口接收：pRxBuffPtr数据缓存指针，RxXferSize接收的最大数据量，RxXferCount还剩余未接收的数据量</li>
</ul>
<h3 id="使能串口中断函数"><a href="#使能串口中断函数" class="headerlink" title="使能串口中断函数"></a>使能串口中断函数</h3><p>上面的入门应用中，我们用了这句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_UART_ENABLE_IT(&amp;UART1_HandleStructure,UART_IT_RXNE);</span><br></pre></td></tr></table></figure>
<p>实际上，这个仅仅是HAL库中另一个通用函数的一个子函数而已，这里可以通过替换成这个函数来升级功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;UART1_HandleStructure, (<span class="keyword">uint8_t</span> *)aRxBuffer, RXBUFFERSIZE);</span><br></pre></td></tr></table></figure>
<p>这个函数的定义是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check that a Rx process is not already ongoing */</span></span><br><span class="line">  <span class="keyword">if</span> (huart-&gt;RxState == HAL_UART_STATE_READY)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pData == <span class="literal">NULL</span>) || (Size == <span class="number">0U</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Process Locked */</span></span><br><span class="line">    __HAL_LOCK(huart);</span><br><span class="line">    huart-&gt;pRxBuffPtr = pData;	<span class="comment">//缓冲大小</span></span><br><span class="line">    huart-&gt;RxXferSize = Size;	<span class="comment">//接收数据大小</span></span><br><span class="line">    huart-&gt;RxXferCount = Size;	<span class="comment">//接收数据计数</span></span><br><span class="line">    huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;</span><br><span class="line">    huart-&gt;RxState = HAL_UART_STATE_BUSY_RX;</span><br><span class="line">    <span class="comment">/* Process Unlocked */</span></span><br><span class="line">    __HAL_UNLOCK(huart);</span><br><span class="line">    <span class="comment">/* Enable the UART Parity Error Interrupt */</span></span><br><span class="line">    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);	<span class="comment">//启用奇偶校验中断</span></span><br><span class="line">    <span class="comment">/* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */</span></span><br><span class="line">    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);</span><br><span class="line">    <span class="comment">/* Enable the UART Data Register not empty Interrupt */</span></span><br><span class="line">    __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);	<span class="comment">//使能串口数据寄存器非空</span></span><br><span class="line">    <span class="keyword">return</span> HAL_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_BUSY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的aRxBuffer是一个uint8_t型的字符串缓冲区，由用户定义，RXBUFFERSIZE是缓冲区大小，这里如果写1，就和上面的入门应用中的函数有着相同的效果。</p>
<p>一旦接收到1个字符，函数就会进入中断向量表中的USART1_IRQHandler函数，但是这一次，我们在中断服务函数中不自己写功能性的函数，而是借助HAL库提供的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口1中断服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_GPIO_TogglePin(LED0_GPIO, LED0_PIN);</span><br><span class="line">	</span><br><span class="line">	HAL_UART_IRQHandler(&amp;UART1_HandleStructure);</span><br><span class="line">	</span><br><span class="line">	HAL_UART_Receive_IT(&amp;UART1_HandleStructure,(<span class="keyword">uint8_t</span> *)&amp;aRxBuffer, RXBUFFERSIZE); <span class="comment">//重新打开串口中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数调用了HAL库中断处理公用函数HAL_UART_IRQHandler，这大致是一个判断中断类型的HAL库函数，里面会调用<strong>回调函数 HAL_UART_RxCpltCallback</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (--huart-&gt;RxXferCount == <span class="number">0U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);		<span class="comment">//关闭中断</span></span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);			<span class="comment">//关闭中断</span></span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);		<span class="comment">//关闭中断</span></span><br><span class="line">      huart-&gt;RxState = HAL_UART_STATE_READY;			<span class="comment">//接收状态：就绪</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)				<span class="comment">//HAL库的宏定义，值为0x0U，用户设为1可以禁用相应的回调函数</span></span></span><br><span class="line">      huart-&gt;RxCpltCallback(huart);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      HAL_UART_RxCpltCallback(huart);				<span class="comment">//回调函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> HAL_OK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，回调函数是放在中断处理函数中的</p>
<p>然后，在USART.c文件中写上回调函数，执行时会覆盖掉系统弱定义的原函数，这里为了方便查看，把中断服务函数也复制过来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *UART1_HandleStructure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_GPIO_TogglePin(LED1_GPIO, LED1_PIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//串口1中断服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HAL_GPIO_TogglePin(LED0_GPIO, LED0_PIN);</span><br><span class="line">	HAL_UART_IRQHandler(&amp;UART1_HandleStructure);<span class="comment">//HAL库提供的中断处理函数，用于将字符输入缓冲区，缓冲区满进入一次回调函数</span></span><br><span class="line">	HAL_UART_Receive_IT(&amp;UART1_HandleStructure,(<span class="keyword">uint8_t</span> *)&amp;aRxBuffer, RXBUFFERSIZE); <span class="comment">//重新打开串口中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使用HAL库提供的函数，配合回调函数就有了一定的优势，那就是，只要接收一个字符，就一定会触发中断，但是在HAL_UART_IRQHandler(&amp;UART1_HandleStructure)中，每接受一个字符，就会自动装载进用户定义的缓冲区，直到装满，才会触发回调函数，就有了一定的实用意义：接收定长的字符串。</p>
<p>这里仅仅作为一个栗子，如果RXBUFFERSIZE缓冲区大小设置为2，而不是之前的1，效果就是，每次接收一个字符，中断服务函数中LED0翻转2次，回调函数中LED1才翻转一次。</p>
<h2 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h2><p>上面我们通过读取缓冲区，已经可以接收定长的字符串了。下面在学习DMA后，可以利用串口空闲中断，接收不定长的字符串，甚至可以在中断中进行数据的处理，这个也可以通过修改库文件实现，但是终究不是很稳妥。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%E7%9A%84%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%E7%9A%84%E6%80%9D%E8%80%83/" itemprop="url">分形与混沌的内在联系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-05T03:21:01+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%BD%A2-%E6%97%B6%E9%97%B4-%E4%B8%8E%E6%B7%B7%E6%B2%8C-%E7%A9%BA%E9%97%B4/" itemprop="url" rel="index">
                    <span itemprop="name">分形(时间)与混沌(空间)</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 在非线性科学中,分形于混沌有着不同的起源,但他们又都是非线性方程所描述的非平衡的过程和结果，这表明他们有着共同的数学祖先一动力系统，混沌吸引子就是分形集,或者说混沌是时间上的分形，而分形是空间上的混沌。混沌事件在不同时间的标度下表现出相似的变化模式，这与分形在空间标度下表现出的自相似性十分相像。</p>
<p>混油主要讨论<strong>非线性动力系统的不稳定</strong>，发散的过程,但系统在相空间总是<strong>收敛于一个边界</strong>与分形的生成过程十分相像。因此，如果说混沌主要研究非线性系统状态在时间上演化过程的行为特征,那么，分形主要研究吸引子在空间上的结构。</p>
<p>混沌状态的<strong>随机性</strong>与初始条件有关；而混沌结构的具体形式或其无规则性也于初始状态有确切关系。混沌吸引子与分形结构都具有自相似性。所以,它们是从<strong>不同侧面</strong>来研究同个问题，分形来自于几何学的研究,而混沌则产生于物理学的研究。</p>
<p>动力系统存在混沌必须满足条件：初始条件的敏感依赖性，拓扑传递性质和周期点的稠密性。对应物理学中产生混沌现象的三个条件：<strong>不可预性</strong>,<strong>不可分解性</strong>以及有<strong>一定规律</strong>成分。</p>
<p>用一句话来概括分形和泥沌的关系:<strong>混沌是时间上的分形，分形是空间上的混沌</strong>。以混沌理论，分形几何学，孤立子理论为主体的非线性科学的标志着科学的发展进入了一个新时代。用<strong>非线性思想</strong>迎接新世纪的种种挑战。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/%E6%88%91%E7%9A%8432%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8_KEY%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/%E6%88%91%E7%9A%8432%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8_KEY%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/" itemprop="url">我的32硬件驱动_KEY按键输入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-28T19:22:12+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx_hal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY0_GPIO			GPIOE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY0_PIN			GPIO_PIN_4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY0_RCC_ENABLE()	__HAL_RCC_GPIOE_CLK_ENABLE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		Read_KEY0			HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_4)  <span class="comment">//利用HAL库读取KEY0键值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY1_GPIO			GPIOE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY1_PIN			GPIO_PIN_3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		KEY1_RCC_ENABLE()	__HAL_RCC_GPIOE_CLK_ENABLE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		Read_KEY1			HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)  <span class="comment">//利用HAL库读取KEY0键值</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">KEY_Scan</span><span class="params">(<span class="keyword">uint8_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KEY.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	KEY0_RCC_ENABLE();								<span class="comment">//这里两个键在同一组IO口</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.Pin = KEY0_PIN | KEY1_PIN;	<span class="comment">//因为在一组端口，可以同时编入两个输入IO口</span></span><br><span class="line">	GPIO_InitStructure.Mode = GPIO_MODE_INPUT;</span><br><span class="line">	GPIO_InitStructure.Pull = GPIO_PULLUP;			<span class="comment">//key接入GND，因此使用上拉输入</span></span><br><span class="line">	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">	</span><br><span class="line">	HAL_GPIO_Init(KEY0_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">KEY_Scan</span><span class="params">(<span class="keyword">uint8_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uint8_t</span> key_up = <span class="number">1</span>;			<span class="comment">//按键松开标志 satic保持变量在函数调用后不消失，并且只在第一次赋值</span></span><br><span class="line">	<span class="keyword">if</span>(mode == <span class="number">1</span>) key_up = <span class="number">1</span>;			<span class="comment">//mode为1，支持连按，mode为0，只有按键松开才使key_up置1，标志着松开</span></span><br><span class="line">	<span class="keyword">if</span>(key_up &amp;&amp; (Read_KEY0 == <span class="number">0</span> || Read_KEY1 == <span class="number">0</span>))	<span class="comment">//读取按键状态，如果有按键按下，并且按键为松开状态</span></span><br><span class="line">	&#123;</span><br><span class="line">		HAL_Delay(<span class="number">10</span>);								<span class="comment">//延时去抖</span></span><br><span class="line">		key_up = <span class="number">0</span>;									<span class="comment">//按键按下标志</span></span><br><span class="line">		<span class="keyword">if</span>(Read_KEY0 == <span class="number">0</span>)			<span class="keyword">return</span> <span class="number">1</span>;		<span class="comment">//KEY0按下，返回1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Read_KEY1 == <span class="number">0</span>)		<span class="keyword">return</span> <span class="number">2</span>;		<span class="comment">//KAY1按下，返回2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Read_KEY0 == <span class="number">1</span> &amp;&amp; Read_KEY1 == <span class="number">1</span>) key_up = <span class="number">1</span>;		<span class="comment">//按键松开，如果不松开，并且不支持连按，就无法进入if循环，触发下一次按下</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">//以上按键都未触发，说明处于无按键按下的状态，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KEY.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> key;					<span class="comment">//定义一个普通变量记录按键扫描返回值</span></span><br><span class="line">	</span><br><span class="line">	Stm32_Clock_Init(RCC_PLL_MUL9);</span><br><span class="line">	HAL_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	KEY_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key = KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_TogglePin(LED0_GPIO, LED0_PIN);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_TogglePin(LED1_GPIO, LED1_PIN);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/%E6%88%91%E7%9A%8432%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8_LED%E7%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/26/%E6%88%91%E7%9A%8432%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8_LED%E7%81%AF/" itemprop="url">我的32硬件驱动_LED灯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-26T19:20:12+08:00">
                2020-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f1xx_hal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*为提高程序的可移植性，宏定义LED引脚位置*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED0_PIN		GPIO_PIN_5							<span class="comment">//宏定义引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED0_GPIO		GPIOB								<span class="comment">//宏定义端口组</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED0_RCC_ENABlE()	__HAL_RCC_GPIOB_CLK_ENABLE()	<span class="comment">//宏定义时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED1_PIN		GPIO_PIN_5		<span class="comment">//同上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED1_GPIO		GPIOE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED1_RCC_ENABlE()	__HAL_RCC_GPIOE_CLK_ENABLE()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED连VCC,高电平点亮,宏定义HAL_GPIO_WritePin()参数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED_ON			GPIO_PIN_RESET		<span class="comment">//亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		LED_OFF			GPIO_PIN_SET		<span class="comment">//灭</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title=".C"></a>.C</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	LED0_RCC_ENABlE();				<span class="comment">//这是个宏函数</span></span><br><span class="line">	LED1_RCC_ENABlE();				<span class="comment">//这是个宏函数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.Pin = LED0_PIN;					<span class="comment">//宏</span></span><br><span class="line">	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;		<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.Pull = GPIO_NOPULL;				<span class="comment">//不上下拉</span></span><br><span class="line">	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;		<span class="comment">//低速</span></span><br><span class="line">	HAL_GPIO_Init(LED0_GPIO, &amp;GPIO_InitStructure);		<span class="comment">//初始化，也用到了.h中的宏</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.Pin = LED0_PIN;</span><br><span class="line">	HAL_GPIO_Init(LED1_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stm32_Clock_Init(RCC_PLL_MUL9);</span><br><span class="line">	HAL_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//HAL_GPIO_TogglePin(LED0_GPIO, LED0_PIN);</span></span><br><span class="line">		<span class="comment">//HAL_Delay(200);</span></span><br><span class="line">		</span><br><span class="line">		HAL_GPIO_WritePin(LED0_GPIO, LED0_PIN, LED_ON);		<span class="comment">//这里就体现出宏定义带来的好处</span></span><br><span class="line">		HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">		HAL_GPIO_WritePin(LED0_GPIO, LED0_PIN, LED_OFF);</span><br><span class="line">		HAL_Delay(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/STM32%E6%97%B6%E9%92%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/24/STM32%E6%97%B6%E9%92%9F/" itemprop="url">STM32系统时钟树总结(基于STM32F103)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-24T15:11:12+08:00">
                2020-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200424154038843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="STM32F103时钟树"></p>
<h2 id="HSE时钟"><a href="#HSE时钟" class="headerlink" title="HSE时钟"></a>HSE时钟</h2><p><strong>HSE：</strong>High Speed External Clock Signal，高速外部时钟</p>
<p><strong>来源：</strong>通常使用8MHz无源晶振，理论上可用4-16MHz</p>
<p><strong>控制：</strong>RCC_CR时钟控制寄存器</p>
<ul>
<li><p>位16：<strong>HSE_ON</strong>(External high-speed clock <strong>enable</strong>)使能</p>
</li>
<li><p>位17：<strong>HSE_RDY</strong>(External high-speed clock <strong>ready flag</strong>)由硬件置1，作为标志位</p>
</li>
</ul>
<h2 id="HSI时钟"><a href="#HSI时钟" class="headerlink" title="HSI时钟"></a>HSI时钟</h2><p><strong>HEI：</strong>Low Speed Internal Clock Signal，高速内部时钟</p>
<p><strong>来源：</strong>芯片内部，内核外部，工作频率为8MHz，当HSE故障时，系统时钟会自动切换到HEI，直到HSE启动成功。</p>
<p><strong>控制：</strong>RCC_CR时钟控制寄存器</p>
<ul>
<li><p>位0：<strong>HEI_ON</strong>(Internal high-speed clock <strong>enable</strong>)控制。</p>
</li>
<li><p>位1：<strong>HSI_RDY</strong>(Internal high-speed clock <strong>ready flag</strong>)由硬件置1，作为标志位</p>
</li>
</ul>
<h2 id="PLLCLK-锁相环时钟）"><a href="#PLLCLK-锁相环时钟）" class="headerlink" title="PLLCLK(锁相环时钟）"></a>PLLCLK(锁相环时钟）</h2><p><strong>锁相环时钟：</strong>PLLCLK</p>
<p><strong>来源：</strong>经过HSE或者(HEI / 2)经过倍频而来</p>
<p><strong>控制：</strong>RCC_CFGR时钟配置寄存器</p>
<ul>
<li>16：<strong>PLL_SRC</strong>(PLL entry clock <strong>source</strong>) 配置时钟源从HSE还是(HEI/2)</li>
<li>17：<strong>PLL_XTPRE</strong> (LSB of division factor PREDIV1)</li>
<li>18-21：<strong>PLL_MUL</strong>(PLL <strong>multiplication</strong> factor) 倍频系数</li>
</ul>
<p><strong>注意：</strong>PLLCLK时钟源如果选择(HEI/2)，则最大的倍频系数是x16，(8/2)x16=64，达不到PLLCLK的最大工作频率72MHz，而如果选用HSE作为PLL的输入时钟源，从HSE输出8M，不分频，之后x9倍频输入PLL，就可以使PLL达到最大工作频率，故一般使用HSE作为PLLCLK的输入时钟源。</p>
<h2 id="SYSCLK-系统时钟"><a href="#SYSCLK-系统时钟" class="headerlink" title="SYSCLK(系统时钟)"></a>SYSCLK(系统时钟)</h2><p><strong>系统时钟：</strong>SYSCLK</p>
<p><strong>来源：</strong>HSI、HSE、PLLCLK</p>
<p><strong>控制：</strong>CRR_CFGR时钟配置寄存器</p>
<ul>
<li>0-1：<strong>SW</strong>(System Clock <strong>Switch</strong>)系统时钟切换，控制系统时钟来源</li>
<li>2-3：<strong>SWS</strong>(System Clock <strong>Switch Status</strong>)状态位，由硬件置位，用于查询系统时钟切换情况，因为系统时钟切换需要时间，故需要确保切换成功。</li>
</ul>
<h2 id="HCLK-高速总线时钟"><a href="#HCLK-高速总线时钟" class="headerlink" title="HCLK(高速总线时钟)"></a>HCLK(高速总线时钟)</h2><p><strong>HELK：</strong>AHB高速总线时钟，速度最高为72M，为AHB总线的外设提供时钟，为Cortex系统定时器(Sys Tick)提供时钟，为内核(FCLK)提供时钟。</p>
<p><strong>AHB：</strong>Advanced High-performace Bus</p>
<p><strong>来源：</strong>系统时钟分频而来，一般设置HCLK = SYSCLK = 72M</p>
<p><strong>控制：</strong>RCC_CFG时钟配置寄存器</p>
<ul>
<li>4-7：<strong>HPRE</strong>(AHB Prescaler) AHB总线预分频</li>
</ul>
<h2 id="PCLK1-PCLK2-ADCCLK时钟："><a href="#PCLK1-PCLK2-ADCCLK时钟：" class="headerlink" title="PCLK1 / PCLK2 / ADCCLK时钟："></a>PCLK1 / PCLK2 / ADCCLK时钟：</h2><p>这三个时钟都是挂载在AHB高速总线上的，其中APB1和APB2总线又挂载了大多数核外片上外设。</p>
<p><strong>PCLK1:</strong>APB1低速总线时钟，频率最高为36M。是为APB1总线的外设提供的时钟，2倍频之后则为APB1总线的定时器2-7提供时钟，若APB1预分频倍率为1，则直接提供给定时器，若分频倍数大于等于2，则2倍频后输入定时器时钟源，最大为72M。</p>
<p><strong>PCLK2:</strong>APB2高速总线时钟，频率最高为72M。是为APB1总线的外设提供的时钟，2倍频之后则为APB1总线的定时器1和8提供时钟，若APB1预分频倍率为1，则直接提供给定时器，若分频倍数大于等于2，则2倍频后输入定时器时钟源，最大也为72M。</p>
<p><strong>ADCCLK：</strong>提供给ADC外设使用的时钟，ADC预分频器将来自AHB高速总线的时钟频率经过2/4/6/8分频后输入ADCCLK，最大的工作频率为14M，</p>
<p><strong>来源：</strong>HCLK分频而来，一般配置PCLK1 = HALK / 2 = 36M</p>
<p><strong>控制：</strong>RCC_CFGR时钟配置寄存器</p>
<ul>
<li>8-10：<strong>PPRE1</strong> (APB low-speed prescaler (APB1)) 低速APB1预分频</li>
<li>11-13：<strong>PPRE2</strong>(APB high-speed prescaler (APB2)) 高速APB2预分频</li>
</ul>
<h2 id="RTC时钟"><a href="#RTC时钟" class="headerlink" title="RTC时钟"></a>RTC时钟</h2><p><strong>RCT时钟：</strong>为芯片内部的RTC外设提供的时钟。</p>
<p><strong>来源：</strong>HSE_RTC (HES分频得到)，LSE (32.7668KHz的外部低速晶振)，LEI (32KHz)。</p>
<p><strong>控制：</strong>RCC_BDCR(RCC备份域控制寄存器)</p>
<ul>
<li>8-9：<strong>RTC_SEL</strong> (RTC clock source <strong>selection</strong>) RTC时钟源选择寄存器</li>
<li>15：<strong>RTC_EN</strong> (RTC clock <strong>enable</strong>) RTC时钟使能寄存器</li>
</ul>
<h2 id="IWDGCLK-独立看门狗时钟"><a href="#IWDGCLK-独立看门狗时钟" class="headerlink" title="IWDGCLK (独立看门狗时钟)"></a>IWDGCLK (独立看门狗时钟)</h2><p><strong>来源：</strong>由LSI提供</p>
<h2 id="MCO时钟输出"><a href="#MCO时钟输出" class="headerlink" title="MCO时钟输出"></a>MCO时钟输出</h2><p><strong>MCO：</strong>Microcontroller Clock Output，微控制器时钟输出，由PA8复用而来</p>
<p><strong>来源：</strong>(PLLCLK / 2)，HSE，HSI，SYSCLK。</p>
<p><strong>控制：</strong>RCC_CFGR时钟配置寄存器</p>
<ul>
<li>24-27：<strong>MCO</strong> (Microcontroller clock output) 设置时钟输出的时钟源</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/2020042415550525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="时钟树总结"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/17/%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/17/%E5%87%BD%E6%95%B0/" itemprop="url">函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-17T21:46:12+08:00">
                2020-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">C语言学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的说明"><a href="#函数的说明" class="headerlink" title="函数的说明"></a>函数的说明</h2><ul>
<li>一个源程序文件由一个或多个函数组成。</li>
<li>一个C程序由一个或多个源程序文件组成。</li>
<li>C程序的执行从<strong>main函数</strong>开始，调用其他函数后流程回到main函数，在main函数中结束整个程序运行。</li>
<li>所有函数都是平行的，即函数定义时是互相独立的，一个函数并不从属于另一个函数。</li>
<li>函数还有很多叫法，比如方法、子例程或程序，等等。</li>
</ul>
<h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><ul>
<li>标准库函数</li>
<li>用户自定义变量</li>
</ul>
<h2 id="需要清楚的基本概念"><a href="#需要清楚的基本概念" class="headerlink" title="需要清楚的基本概念"></a>需要清楚的基本概念</h2><ul>
<li><p>函数声明：函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数</p>
</li>
<li><p>函数定义：函数<strong>定义</strong>提供了函数的实际主体</p>
</li>
<li><p>函数调用</p>
</li>
<li><p>形参(形式参数)</p>
</li>
<li><p>实参(实际参数)</p>
</li>
<li><p>函数值</p>
</li>
<li><p>函数的执行过程</p>
</li>
<li><p>return语句的作用</p>
</li>
</ul>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><ul>
<li>举一个例子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y)</span></span>;	<span class="comment">//声明函数，通常封装在inc(头文件)文件里，是函数的目录，在调用前必须先声明，或者需要包含声明过函数的头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d, %d"</span>, &amp;a, b);</span><br><span class="line">    c = getMax(a, b);				<span class="comment">//调用函数 其中a, b为实参(实际参数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Max = %d"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y)</span>	<span class="comment">//定义函数，x, y 为形参(形式参数)，int定义返回值的类型</span></span></span><br><span class="line"><span class="function"></span>&#123;										<span class="comment">//若无返回值，则用void</span></span><br><span class="line">    z = x;				<span class="comment">//函数内的处理</span></span><br><span class="line">    <span class="keyword">if</span> (z &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;			<span class="comment">//"return"返回函数的返回值，如果是一个过程处理函数，则"return 0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，调用getMax函数，就是先为形式参数分配物理内存，再把实际参数传递给对应的形式参数，然后在函数体内进行运行，直到return，结束函数调用，计算机释放形式参数的物理内存，将返回值传递到调用函数的地方。</p>
<h2 id="对函数返回值的理解"><a href="#对函数返回值的理解" class="headerlink" title="对函数返回值的理解"></a>对函数返回值的理解</h2><p>当程序执行到return语句时，程序的流程就返回到调用函数的地方(即结束函数调用)，并带回函数值。在同一个函数内，允许出现多处return语句，但是这个执行这个函数时只执行其中的一个，且只能执行一次。</p>
<h2 id="数组作为函数的参数-重要"><a href="#数组作为函数的参数-重要" class="headerlink" title="数组作为函数的参数(重要)"></a>数组作为函数的参数(重要)</h2><h3 id="理解下面的要点："><a href="#理解下面的要点：" class="headerlink" title="理解下面的要点："></a>理解下面的要点：</h3><ul>
<li><p>用数组作函数参数时，形参是数组，相应的实参应是数组名</p>
</li>
<li><p>形参数组与实参数组类型应一致</p>
</li>
<li><p>形参是数组，在函数调用时， 相对应的实参是数组名(地址)，实参数组的首元素的地址传给形参。因此形参数组名获得了实参数组的首元素地址。因此形参数组元素（arr[0]）和实参数组首元素（score[0]）具有同一地址，他们共占同一存储单元，score[n]和arr[n]指的是同一单元，具有相同的值。</p>
</li>
<li><p>一维形参数组可以不指定大小，在定义数组时在数组名后面跟一个空的方括号。有时为了在被调用函数中处理数条组元素的需要，可以另设一形参，传递需要处理的数组元素的个数。</p>
</li>
<li><p>用数组名作函数实参时,传递的是数组的起始地址,而不是数据元素的值,因此形参与实参两个数组共占同一段内存单元。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/2020042111502481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="数组作形参"></p>
</li>
<li><p>形参数组各元素的值发生变化会使实参数组元素的值同时发生变化。</p>
</li>
</ul>
<h3 id="下面举例应用"><a href="#下面举例应用" class="headerlink" title="下面举例应用"></a>下面举例应用</h3><h4 id="例1：无返回值"><a href="#例1：无返回值" class="headerlink" title="例1：无返回值"></a>例1：无返回值</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200421115431854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="例1"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* userCode(&lt;50字符): 自定义函数之原型声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_nx</span><span class="params">(<span class="keyword">char</span> str1[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input a string: "</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	Get_nx(str);  <span class="comment">/* userCode(&lt;50字符): 调用函数将字符串str逆序存放 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThe result is: %s\n"</span>, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Code Begin：考生在此后完成自定义函数的设计，行数不限 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_nx</span><span class="params">(<span class="keyword">char</span> str1[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, len;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	</span><br><span class="line">	len = <span class="built_in">strlen</span>(str1);		<span class="comment">//题目包含string库，若不包含需要自己获取长度，或者在下面的for循环中使用i, j两个参数标记首尾, 包夹处理</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span> - i; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = str1[i];				<span class="comment">//交换第1个和最后1个数</span></span><br><span class="line">		str1[i] = str1[len - <span class="number">1</span> - i];</span><br><span class="line">		str1[len - <span class="number">1</span> - i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>无返回值的函数，主要用于输入，输出，或者一个处理过程。</li>
<li>无返回值的函数，定义应当使用void 关键词，在函数体内无return，即不进行返回操作。</li>
</ul>
<h4 id="例2：有返回值"><a href="#例2：有返回值" class="headerlink" title="例2：有返回值"></a>例2：有返回值</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200421120451346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="例2"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* userCode(&lt;50字符): 自定义函数之原型声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">6</span>], arrayB[<span class="number">10</span>], arrayC[<span class="number">15</span>], sumA, sumB, sumC;</span><br><span class="line"></span><br><span class="line">	sumA = Get_sum(arrayA, <span class="number">6</span>);  <span class="comment">/* userCode(&lt;50字符): 调用函数读 6个数到arrayA中，并计算和 */</span></span><br><span class="line">	sumB = Get_sum(arrayB, <span class="number">10</span>);  <span class="comment">/* userCode(&lt;50字符): 调用函数读10个数到arrayB中，并计算和 */</span></span><br><span class="line">	sumC = Get_sum(arrayC, <span class="number">15</span>);  <span class="comment">/* userCode(&lt;50字符): 调用函数读15个数到arrayC中，并计算和 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\narrayA[0]=%3d, arrayA[ 5]=%3d, sum(arrayA)=%d"</span>, arrayA[<span class="number">0</span>], arrayA[<span class="number">5</span>], sumA);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\narrayB[0]=%3d, arrayB[ 9]=%3d, sum(arrayB)=%d"</span>, arrayB[<span class="number">0</span>], arrayB[<span class="number">9</span>], sumB);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\narrayC[0]=%3d, arrayC[14]=%3d, sum(arrayC)=%d\n"</span>, arrayC[<span class="number">0</span>], arrayC[<span class="number">14</span>], sumC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Code Begin：考生在此后完成自定义函数的设计，行数不限 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入%d个数: "</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">		sum += <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<p>读题发现，题目要求中：程序的功能是1、键盘读入 (输入)，2、计算数组元素的和(处理)，3、输出。而观察题目给的源程序，1，3两步，已经给出，并且输出函数用到的arrA，arrB两个实际参数<strong>没有赋值</strong>，说明在调用函数的时候，需要有值赋给实际参数，那么就需要一个有返回值的函数。</p>
<h4 id="例3：C语言考试例子"><a href="#例3：C语言考试例子" class="headerlink" title="例3：C语言考试例子"></a>例3：C语言考试例子</h4><p>有以下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> c[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> c0, <span class="keyword">int</span> c1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;, b[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    swap1(a);</span><br><span class="line">    swap2(b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> c[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = c[<span class="number">0</span>];</span><br><span class="line">    c[<span class="number">0</span>] = c[<span class="number">1</span>];</span><br><span class="line">    c[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> c0, <span class="keyword">int</span> c1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = c0;</span><br><span class="line">    c0 = c1;</span><br><span class="line">    c1 = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，两个swap函数本质上都是对两个数进行交换，但是运行的结果是什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>为什么数组元素成功地进行了元素的交换，但是两个数却没有交换呢？</p>
<p>因为swap1，函数变量是数组在调用函数时，形式参数获得了实际参数的数组首地址，进行函数处理时，子函数内<strong>实际上就是在操所实际参数地址的元素</strong>，对实际参数的影响是实时的，而不需要ruturn来传递这种影响。</p>
<p>但是swap2，函数变量不是数组，因此，主函数传入子函数的途径只有：开始调用子函数，子函数在计算机内开辟两块临时的物理内存，子函数将外部的实参赋给形参，储存在<strong>临时</strong>的地址中，之后在子函数内进行的<strong>任意操作</strong>，<strong>都是</strong>对单独存放的形参进行操所，只要没有return，或者即使有return，但并没有赋给原来的实参，子函数执行结束后，即结束函数调用，清除物理内存，<strong>全过程对实际参数不能造成任何影响</strong>。</p>
<p>我们结合这个例子总结一下函数调用时参数传递的途径：</p>
<ol>
<li>在非数组作为参数，实际参数传递给形式参数。</li>
<li>在数组作为参数时，实际参数与形式参数共用储存地址，在调用开始实参传递给形参，调用过程中形参的改变也会传递到实参。</li>
<li>通过return语句，把函数值返回调用函数。</li>
<li>通过全局变量。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%E7%82%B9%E7%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%E7%82%B9%E7%81%AF/" itemprop="url">STM32学习记录——第一步——点灯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-15T19:45:22+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">STM32学习记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><p>实践操作很多MCU的第一步应该都是点灯吧，硬件界的Hello World，故曰点灯工程师。</p>
<p>下面来看看如何让开发板上的一个LED亮起来。</p>
<h2 id="1、自己写一个简陋版的标准固件库"><a href="#1、自己写一个简陋版的标准固件库" class="headerlink" title="1、自己写一个简陋版的标准固件库"></a>1、自己写一个简陋版的标准固件库</h2><p>权衡CPU的运算能力和官方固件库带来的便捷，可以知道，在大多数对CPU性能无需太多优化的情况下，使用固件库编程都会是主流，因此，我想参考ST官方的<strong>标准固件库</strong>来写一段点灯用得上的迷你库，为什么不是参考HAL库？因为看起来更复杂，在硬件层到用户层的距离比较远，说到底是我现在看不懂，太菜呗。</p>
<h3 id="下面先编写”stm32f10x-gpio-h”"><a href="#下面先编写”stm32f10x-gpio-h”" class="headerlink" title="下面先编写”stm32f10x_gpio.h”"></a>下面先编写”stm32f10x_gpio.h”</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __IO				volatile	<span class="comment">//防止编译器优化</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>		u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> short <span class="keyword">int</span>	u16;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPH_BASE			0x40000000U</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APB2PERIPH_BASE		(PERIPH_BASE + 0x00010000U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AHBPERIPH_BASE		(PERIPH_BASE + 0x00020000U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_BASE			(AHBPERIPH_BASE + 0x00001000U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 寄存器结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__IO u32 CRL; <span class="comment">// 端口配置低寄存器， 地址偏移 0X00</span></span><br><span class="line">	__IO u32 CRH; <span class="comment">// 端口配置高寄存器， 地址偏移 0X04</span></span><br><span class="line">	__IO u32 IDR; <span class="comment">// 端口数据输入寄存器， 地址偏移 0X08</span></span><br><span class="line">	__IO u32 ODR; <span class="comment">// 端口数据输出寄存器， 地址偏移 0X0C</span></span><br><span class="line">	__IO u32 BSRR; <span class="comment">// 端口位设置/清除寄存器，地址偏移 0X10</span></span><br><span class="line">	__IO u32 BRR; <span class="comment">// 端口位清除寄存器， 地址偏移 0X14</span></span><br><span class="line">	__IO u32 LCKR; <span class="comment">// 端口配置锁定寄存器， 地址偏移 0X18</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别求出各组IO端口的基地址映射</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_BASE			(APB2PERIPH_BASE + 0x00000800U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_BASE			(APB2PERIPH_BASE + 0x00000C00U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOC_BASE			(APB2PERIPH_BASE + 0x00001000U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOD_BASE			(APB2PERIPH_BASE + 0x00001400U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOE_BASE			(APB2PERIPH_BASE + 0x00001800U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOF_ASE			(APB2PERIPH_BASE + 0x00001C00U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOG_BASE			(APB2PERIPH_BASE + 0x00002000U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 外设声明</span></span><br><span class="line"><span class="comment">/*强制类型转换，将GPIOA转换为从GPIOA的基地址开始的结构体指针，</span></span><br><span class="line"><span class="comment">通过访问其中的成员，就是操作这一块内存中的对应的32位,</span></span><br><span class="line"><span class="comment">访问成员就相当于之前的第一个*,是解地址的过程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA				((GPIO_TypeDef *) GPIOA_BASE)		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB				((GPIO_TypeDef *) GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOC				((GPIO_TypeDef *) GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOD				((GPIO_TypeDef *) GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOE				((GPIO_TypeDef *) GPIOE_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOF				((GPIO_TypeDef *) GPIOF_BASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOG				((GPIO_TypeDef *) GPIOG_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RCC 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__IO u32 CR;</span><br><span class="line">	__IO u32 CFGR;</span><br><span class="line">	__IO u32 CIR;</span><br><span class="line">	__IO u32 APB2RSTR;</span><br><span class="line">	__IO u32 APB1RSTR;</span><br><span class="line">	__IO u32 AHBENR;</span><br><span class="line">	__IO u32 APB2ENR;</span><br><span class="line">	__IO u32 APB1ENR;</span><br><span class="line">	__IO u32 BDCR;</span><br><span class="line">	__IO u32 CSR;</span><br><span class="line">	__IO u32 AHBRSTR;</span><br><span class="line">	__IO u32 CFGR2;</span><br><span class="line">&#125; RCC_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RCC 外设声明</span></span><br><span class="line"><span class="comment">/*强制类型转换，将GPIOA转换为从GPIOA的基地址开始的结构体指针，</span></span><br><span class="line"><span class="comment">通过访问其中的成员，就是操作这一块内存中的对应的32位,</span></span><br><span class="line"><span class="comment">访问成员就相当于之前的第一个*,是解地址的过程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC					((RCC_TypeDef *) RCC_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>怎么去理解呢，先看这里面所有的<strong>#define</strong>语句，可以看到STM32的硬件地址具有严格的分级结构，我们可以利用<strong>宏定义的嵌套</strong>来轻松的完成从<strong>外设基地址</strong>，到<strong>APB2总线地址</strong>，再到APB2外设<strong>GPIO基地址</strong>，最后到<strong>GPIO寄存器</strong>的映射，最后一步<strong>解地址</strong>的环节，在定义<strong>GPIOx</strong>的时候完成的，这样，当我们包含这个头文件，在main函数或者GPIO外设函数中写<strong>GPIOx</strong>，都会被直接翻译为GPIOx的基地址，这里主要应用了<strong>地址偏移</strong>的概念。</p>
<p>翻手册，发现GPIO和RCC的寄存器竟然都是32为的，这一看就得用结构体啊，这样就把GPIOx这一块地址，又分成了一个个寄存器地址，下面的GPIO外设头文件就能用到。</p>
<p>如果不包含这个头文件，我们的点灯程序主体是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面的地址宏定义略去，一样通过地址偏移实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2ENR |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">1</span>*<span class="number">4</span>));			<span class="comment">//开启PC的时钟</span></span><br><span class="line">	GPIOC_CRH &amp;= ~(<span class="number">0x0F</span> &lt;&lt; (<span class="number">4</span>*<span class="number">5</span>));			<span class="comment">//13 - 8 = 5</span></span><br><span class="line">	GPIOC_CRH |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">4</span>*<span class="number">5</span>));			<span class="comment">//设置PC13推挽输出 低速模式</span></span><br><span class="line">	GPIOC_ODR &amp;= ~(<span class="number">0x01</span> &lt;&lt; (<span class="number">1</span>*<span class="number">13</span>));			<span class="comment">//端口数据输出寄存器，PC13输出</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含了这个头文件，我们可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC-&gt;APB2ENR |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">1</span>*<span class="number">4</span>));			<span class="comment">//开启PC的时钟</span></span><br><span class="line">	GPIOC-&gt;CRH &amp;= ~(<span class="number">0x0F</span> &lt;&lt; (<span class="number">4</span>*<span class="number">5</span>));				<span class="comment">//13 - 8 = 5</span></span><br><span class="line">	GPIOC-&gt;CRH |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">4</span>*<span class="number">5</span>));				<span class="comment">//设置PC13推挽输出 低速模式</span></span><br><span class="line">	GPIOC-&gt;ODR &amp;= ~(<span class="number">0x01</span> &lt;&lt; (<span class="number">1</span>*<span class="number">13</span>));			<span class="comment">//端口数据输出寄存器，PC13输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用感觉变化不大？感觉确实啊，不就是个结构体成员吗？我开始也是这么想的，但现在却认为这是同向硬件可移植性的重要一步。</p>
<p>什么？想要一个函数实现LED亮灭？继续看。</p>
<h3 id="“stm32f10x-GPIO-h”"><a href="#“stm32f10x-GPIO-h”" class="headerlink" title="“stm32f10x_GPIO.h”"></a>“stm32f10x_GPIO.h”</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_0                 ((u16)0x0001)  <span class="comment">/* Pin 0 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_1                 ((u16)0x0002)  <span class="comment">/* Pin 1 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_2                 ((u16)0x0004)  <span class="comment">/* Pin 2 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_3                 ((u16)0x0008)  <span class="comment">/* Pin 3 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_4                 ((u16)0x0010)  <span class="comment">/* Pin 4 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_5                 ((u16)0x0020)  <span class="comment">/* Pin 5 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_6                 ((u16)0x0040)  <span class="comment">/* Pin 6 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_7                 ((u16)0x0080)  <span class="comment">/* Pin 7 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_8                 ((u16)0x0100)  <span class="comment">/* Pin 8 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_9                 ((u16)0x0200)  <span class="comment">/* Pin 9 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_10                ((u16)0x0400)  <span class="comment">/* Pin 10 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_11                ((u16)0x0800)  <span class="comment">/* Pin 11 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_12                ((u16)0x1000)  <span class="comment">/* Pin 12 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_13                ((u16)0x2000)  <span class="comment">/* Pin 13 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_14                ((u16)0x4000)  <span class="comment">/* Pin 14 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_15                ((u16)0x8000)  <span class="comment">/* Pin 15 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_All               ((u16)0xFFFF)  <span class="comment">/* All pins selected */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u16 GPIO_Pin;</span><br><span class="line">	u16 GPIO_Speed;</span><br><span class="line">	u16 GPIO_Mode;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"><span class="comment">//但是Speed只有3种，Mode只有8种，远远不到16种，为防止引用结构体时出错，运用枚举定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_Speed_10MHz = <span class="number">1</span>,</span><br><span class="line">	GPIO_Speed_2MHz,</span><br><span class="line">	GPIO_Speed_50MHz</span><br><span class="line">&#125;GPIOSpeed_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_Mode_AIN = <span class="number">0x0</span>,					<span class="comment">//模拟输入		(0000 0000)b</span></span><br><span class="line">	GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,			<span class="comment">//浮空输入		(0000 0100)b</span></span><br><span class="line">	GPIO_Mode_IPD = <span class="number">0x28</span>,					<span class="comment">//下拉输入		(0010 1000)b</span></span><br><span class="line">	GPIO_Mode_IPU = <span class="number">0x48</span>,					<span class="comment">//上拉输入		(0100 1000)b</span></span><br><span class="line">	</span><br><span class="line">	GPIOA_Mode_Out_OD = <span class="number">0x14</span>,				<span class="comment">//开漏输出		(0001 0100)b</span></span><br><span class="line">	GPIOA_Mode_Out_PP = <span class="number">0x10</span>,				<span class="comment">//推挽输出		(0001 0000)b</span></span><br><span class="line">	GPIOA_Mode_AF_OD = <span class="number">0x1C</span>,				<span class="comment">//复用开漏输出	(0001 1100)b</span></span><br><span class="line">	GPIOA_Mode_AF_PP = <span class="number">0x18</span>					<span class="comment">//复用推挽输出	(0001 1000)b</span></span><br><span class="line">&#125; GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBit</span><span class="params">(GPIO_TypeDef *GPIOx, u16 GPIO_Pin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBit</span><span class="params">(GPIO_TypeDef *GPIOx, u16 GPIO_Pin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>有了包含基本外设基地址的头文件，开始编写GPIO头文件，这里的关键有两个：</p>
<ul>
<li>16位无符号二进制位来宏定义GPIO_PIN_x，这个源于各个各个GPIO寄存器的配置方式，都可以用这个16位二进制进行变换后赋给寄存器，达到配置的目的。</li>
<li>对于功能性的配置关键词，使用枚举定义( 这个我们C语言竟然没学，害，卑微的非计算机专业 )。</li>
</ul>
<h3 id="“stm32f10x-GPIO-c”"><a href="#“stm32f10x-GPIO-c”" class="headerlink" title="“stm32f10x_GPIO.c”"></a>“stm32f10x_GPIO.c”</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x_gpio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBit</span><span class="params">(GPIO_TypeDef *GPIOx, u16 GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIOx-&gt;BSRR |= GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBit</span><span class="params">(GPIO_TypeDef *GPIOx, u16 GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIOx-&gt;BRR |= GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u32 currentmode = <span class="number">0x00</span>, currentpin = <span class="number">0x00</span>, pinpos = <span class="number">0x00</span>, pos = <span class="number">0x00</span>;</span><br><span class="line">  u32 tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*---------------------------- GPIO Mode Configuration -----------------------*/</span></span><br><span class="line">  currentmode = ((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)<span class="number">0x0F</span>);		<span class="comment">//把输入参数GPIO_Mode的低四位暂存在currentmode中</span></span><br><span class="line">  <span class="keyword">if</span> ((((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)<span class="number">0x10</span>)) != <span class="number">0x00</span>)		<span class="comment">//判断GPIO_Mode的第四位(0001 0000)，判断输入(0)还是输出(1)</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* Check the parameters */</span></span><br><span class="line">    <span class="comment">/* Output mode */</span></span><br><span class="line">    currentmode |= (u32)GPIO_InitStruct-&gt;GPIO_Speed;			<span class="comment">//输出模式，则需要设置输出速度</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*---------------------------- GPIO CRL Configuration ------------------------*/</span></span><br><span class="line">  <span class="comment">/* Configure the eight low port pins */</span></span><br><span class="line">  <span class="keyword">if</span> (((u32)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((u32)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)			<span class="comment">//CRL第八位端口配置，PIN0-PIN7</span></span><br><span class="line">  &#123;</span><br><span class="line">    tmpreg = GPIOx-&gt;CRL;										<span class="comment">//tmpreg暂存CRL的值</span></span><br><span class="line">    <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)				<span class="comment">//for循环查找具体的端口</span></span><br><span class="line">    &#123;</span><br><span class="line">      pos = ((u32)<span class="number">0x01</span>) &lt;&lt; pinpos;								<span class="comment">//pos为1左移pinpos位</span></span><br><span class="line">      <span class="comment">/* Get the port pins position */</span></span><br><span class="line">      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line">      <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">      &#123;</span><br><span class="line">        pos = pinpos &lt;&lt; <span class="number">2</span>;										<span class="comment">//pinpos左移2位，二进制相当于乘4，由于4位配置一个端口</span></span><br><span class="line">        <span class="comment">/* Clear the corresponding low control register bits */</span></span><br><span class="line">        pinmask = ((u32)<span class="number">0x0F</span>) &lt;&lt; pos;							<span class="comment">//清除对应端口的4位配置信息</span></span><br><span class="line">        tmpreg &amp;= ~pinmask;										</span><br><span class="line">        <span class="comment">/* Write the mode configuration in the corresponding bits */</span></span><br><span class="line">        tmpreg |= (currentmode &lt;&lt; pos);							<span class="comment">//tmpreg本来备份了CRL的原始信息，现在或上需要配置的端口的4位的置位信息</span></span><br><span class="line">        <span class="comment">/* Reset the corresponding ODR bit */</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)		<span class="comment">//判断是否为下拉输入模式，如果时下拉模式</span></span><br><span class="line">        &#123;</span><br><span class="line">          GPIOx-&gt;BRR = (((u32)<span class="number">0x01</span>) &lt;&lt; pinpos);					<span class="comment">//操作BRR对应的位置位，即实现下拉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>													<span class="comment">//else为上拉模式</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Set the corresponding ODR bit */</span></span><br><span class="line">          <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">          &#123;</span><br><span class="line">            GPIOx-&gt;BSRR = (((u32)<span class="number">0x01</span>) &lt;&lt; pinpos);				<span class="comment">//操作BSRR对应的位置位，即实现上拉</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*---------------------------- GPIO CRH Configuration ------------------------*/</span></span><br><span class="line">  <span class="comment">/* Configure the eight high port pins */</span></span><br><span class="line">  <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//这里一坨跟上面一样的代码，是配置高8位端口的，博客空间有限，略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不解释(解释都在注释里)。</p>
<h2 id="2、使用自己的简陋版本固件库编程"><a href="#2、使用自己的简陋版本固件库编程" class="headerlink" title="2、使用自己的简陋版本固件库编程"></a>2、使用自己的简陋版本固件库编程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x_gpio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;		<span class="comment">//给变量GPIO_InitStructure定义GPIO初始化结构体</span></span><br><span class="line">	RCC-&gt;APB2ENR |= (<span class="number">0x01</span> &lt;&lt; (<span class="number">1</span>*<span class="number">4</span>));			<span class="comment">//开启PC的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIOA_Mode_Out_PP;		<span class="comment">//为初始化结构体成员GPIO_Mode赋值</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_13;				<span class="comment">//为初始化结构体成员GPIO_PIN赋值</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;		<span class="comment">//为初始化结构体成员GPIO_Speed赋值</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);		<span class="comment">//两个形参，前一个是端口寄存器结构体定义，已经在stm32f10x.h中define成了绝对地址，</span></span><br><span class="line">												<span class="comment">//后一个是端口初始化结构体定义，需要填写结构体地址</span></span><br><span class="line">	GPIO_ResetBit(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span><span class="params">(<span class="keyword">void</span>)</span>		<span class="comment">//startup.s中有经过这一段函数的预编译指令，空，避免编译器报错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么？更复杂了？</p>
<p>你细品。。。</p>
<p>有没有发现这个结构体很灵性？是不是很直观，都不需要查手册了吧，知道自己想干嘛，直接往结构体里塞对应功能的宏名就行了，地址啥的在头文件里呢。</p>
<p>这个其实可以另外新建一个LED.c，放在另一个独立的硬件包里，起一个名字<strong>“GPIO_Init()”</strong>，里面放GPIO的RCC和寄存器初始化，在主函数中，就能实现一句话初始化，这里就不演示了。</p>
<p>另外这个<strong>“GPIO_Setbit”</strong>函数也是同样的道理，让你编程的时候甚至忘掉了底层。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/%E9%AB%98%E6%95%B0%E2%80%94%E2%80%94%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silicon4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silicon4">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/%E9%AB%98%E6%95%B0%E2%80%94%E2%80%94%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%EF%BC%9F/" itemprop="url">高数——三重积分的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-17T20:21:43+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%95%B0/" itemprop="url" rel="index">
                    <span itemprop="name">高数</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="三重积分的几何意义是四维超体积？"><a href="#三重积分的几何意义是四维超体积？" class="headerlink" title="三重积分的几何意义是四维超体积？"></a>三重积分的几何意义是四维超体积？</h1><p>高数老师讲过，，先别急，我们换定积分的几何意义，是曲边梯形的面积，二重积分的几何意义，是曲顶柱体的体积，那三重积分是什么呢？可能老师就会讲，这是一个封闭三维几何体的质量。</p>
<p>咦？怎么从面积，到体积，体积怎么就到质量了呢？怎么从几何意义，似乎突然又扯到了物理的质量呢？且慢，我们换一种方式理解。</p>
<h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><script type="math/tex; mode=display">\int\limits_a^b {f(x)dx}</script><p>如果f(x)=1，a=0, b=1上面这个式子这是什么？从0到1，f(x) = 1的定积分呗。看到它，你的脑子里肯定会浮现出一个直角坐标轴，表示自变量x从0到1，函数y = 1与x轴围城的阴影部分的面积。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200418230915377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="f(x)=1定积分"></p>
<p>这是二维吗？是的，图像当然是二维的。但是你想想，这个函数f(x) = 1是几维图像呢？一维。准确的说，这是实实在在的一维<a href="[https://baike.baidu.com/item/%E7%9B%B8%E7%A9%BA%E9%97%B4/8172498?fr=aladdin](https://baike.baidu.com/item/相空间/8172498?fr=aladdin">相空间</a>)，你画在平面直角坐标系中，那只不过是我们的习惯而已，我们只是习惯了y是因变量，x是自变量的形式，并习惯把它画出来。</p>
<p>假如我们换一种方式去理解，f(x)其实是一种描述<strong>一维直线的线密度</strong>的函数。</p>
<p>为什么说是描述呢，因为一些复杂的情况下，f(x)是个隐函数，这个就和物理的上，或者说我们习惯的密度和质量的定义就不一样了。那么对f(x)在一定区间上的定积分，其结果就是这条<strong>直线段</strong>的质量，积分区间就描述了直线的端点 (或者用更广泛的说法，是<strong>一维区域的边界</strong>)。</p>
<p>f(x)就是一种映射，一个x值，就映射了一个点的无限小<strong>邻域</strong>的密度，比如f(x) = 1,任意x带入，就是x点的<strong>线密度</strong>1,而线长度，就是积分区间，就是区间(0, 1)的长度，1 * 1就是1。</p>
<p>而我们积分得到面积的想法，就是把这条直线，搬到了x轴上，用y去描述这种线密度。</p>
<p>如果f(x)=C (const)，则说明线质量是均匀分布的。</p>
<p>我用了这么多不怎么直观的描述，就是为了保证严谨性，这种理解，对于任何可积的一元函数都适用。</p>
<h3 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h3><script type="math/tex; mode=display">
\int\!\!\!\int\limits_{\rm{D}} {f(x,y)d\sigma }</script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20200418230925623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70" alt="二重积分"></p>
<p>如果上面一重定积分的概念你理解了，那么这个就很好理解，这个二重积分，f(x, y)就是描述一个以x, y两个平面维度为自变量的平面的<strong>面密度</strong>的函数。而D则限定了一个区域，边界，积分的结果就是平面内D区域的<strong>面质量</strong>。</p>
<p>如果f(x, y)=C (const)，则说明面质量是均匀分布的。</p>
<h3 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h3><script type="math/tex; mode=display">
\mathop{\int\!\!\!\int\!\!\!\int}\limits_{\kern0pt \Omega } {f(x,y,z)dV}</script><p>这样就很好地统一起来了吧，三重积分，f(x, y, z)就是描述以x, y, z空间维度为自变量的平直空间的<strong>体密度</strong>的函数。Omega则限定了一个三维区域，积分的结果是空间内Omega区域的<strong>体质量</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在当前阶段，老师永远不会跟你说三重积分，要用思维超体的体积去想象，因为常人根本想象不出来呀，这还不得研究高维几何学的数学家，或者研究弦论的物理学家才能想象？研究四维物体，可不仅仅看看是投影到三维空间的棱线就能弄清楚的(更别说有些人连投影都想象不出来？)。</p>
<p>那么，用质量去统一理解定积分，二重积分，以及三重积分，更加具有规律性，有助于培养一种归纳的思维，以后的数学物理应用方面，也理解的更加透彻。</p>
<h4 id="在hexo插入数学公式"><a href="#在hexo插入数学公式" class="headerlink" title="在hexo插入数学公式"></a><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在hexo插入数学公式</a></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://img-blog.csdnimg.cn/20200419121558948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcmJvbjY=,size_16,color_FFFFFF,t_70"
                alt="Silicon4" />
            
              <p class="site-author-name" itemprop="name">Silicon4</p>
              <p class="site-description motion-element" itemprop="description">Silicon4的个人博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="skype:yourname?call|chat" target="_blank" title="Skype">
                      
                        <i class="fa fa-fw fa-skype"></i>Skype</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silicon4</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>
</html>
